---
title: '[NOI2002] 银河英雄传说'
date: 2018-08-09 21:43:30
tags: 
  - 并查集
  - 带权并查集
categories: 题解
summary: ' '
---

# 题目

[题目链接](https://www.luogu.org/problemnew/show/P1196)

## 题目描述

公元五八○一年，地球居民迁至金牛座α第二行星，在那里发表银河联邦创立宣言，同年改元为宇宙历元年，并开始向银河系深处拓展。

宇宙历七九九年，银河系的两大军事集团在巴米利恩星域爆发战争。泰山压顶集团派宇宙舰队司令莱因哈特率领十万余艘战舰出征，气吞山河集团点名将杨威利组织麾下三万艘战舰迎敌。

杨威利擅长排兵布阵，巧妙运用各种战术屡次以少胜多，难免恣生骄气。在这次决战中，他将巴米利恩星域战场划分成 $30000$ 列，每列依次编号为 $1, 2, …,30000$。之后，他把自己的战舰也依次编号为 $1, 2, …, 30000$，让第 $i$ 号战舰处于第 $i$ 列 $(i = 1, 2, …, 30000)$，形成“一字长蛇阵”，诱敌深入。这是初始阵形。当进犯之敌到达时，杨威利会多次发布合并指令，将大部分战舰集中在某几列上，实施密集攻击。合并指令为 $M_{i,j}$，含义为第 $i$ 号战舰所在的整个战舰队列，作为一个整体（头在前尾在后）接至第j号战舰所在的战舰队列的尾部。显然战舰队列是由处于同一列的一个或多个战舰组成的。合并指令的执行结果会使队列增大。

然而，老谋深算的莱因哈特早已在战略上取得了主动。在交战中，他可以通过庞大的情报网络随时监听杨威利的舰队调动指令。

在杨威利发布指令调动舰队的同时，莱因哈特为了及时了解当前杨威利的战舰分布情况，也会发出一些询问指令： $C_{i,j}$。该指令意思是，询问电脑，杨威利的第 $i$ 号战舰与第 $j$ 号战舰当前是否在同一列中，如果在同一列中，那么它们之间布置有多少战舰。

作为一个资深的高级程序设计员，你被要求编写程序分析杨威利的指令，以及回答莱因哈特的询问。

最终的决战已经展开，银河的历史又翻过了一页……

## 输入输出格式

### 输入格式

第一行有一个整数 $T(1 \le T \le 500,000)$，表示总共有 $T$ 条指令。

以下有 $T$ 行，每行有一条指令。指令有两种格式：

1.  $M_{i,j}$： $i$ 和 $j$ 是两个整数 $(1 \le i,j \le 30000)$，表示指令涉及的战舰编号。该指令是莱因哈特窃听到的杨威利发布的舰队调动指令，并且保证第 $i$ 号战舰与第 $j$ 号战舰不在同一列。
2.  $C_{i,j}$： $i$ 和 $j$ 是两个整数 $(1 \le i,j \le 30000)$，表示指令涉及的战舰编号。该指令是莱因哈特发布的询问指令。

### 输出格式

依次对输入的每一条指令进行分析和处理：

如果是杨威利发布的舰队调动指令，则表示舰队排列发生了变化，你的程序要注意到这一点，但是不要输出任何信息；

如果是莱因哈特发布的询问指令，你的程序要输出一行，仅包含一个整数，表示在同一列上，第 $i$ 号战舰与第 $j$ 号战舰之间布置的战舰数目。如果第 $i$ 号战舰与第 $j$ 号战舰当前不在同一列上，则输出 $-1$。

### 说明

![数据范围](https://cdn.luogu.org/upload/pic/53.png)

#题解

注意到这个题维护的是一些不相交集合的元素间的相对关系，因此考虑使用带权并查集。

对于两艘战舰，如果我们能知道他们与他们所在的列的第一艘战舰之间的距离，就可以用类似前缀和的方式求出他们之间的距离。所以我们考虑用并查集的权来维护一个数组 `d` ，其中 `d[x]` 表示编号为 `x` 的战舰距离编号为 `fa[x]` 的战舰的距离。为了在合并两列的时候更方便的更新这个信息，我们要再维护一个数组 `cnt` ，其中 `cnt[x]` 表示元素 `cnt` 所在的列的战舰的数量。

我们设 `d[x]` 初值为 `0` ， `cnt[x]` 初值为 `1` 。

在进行并查集的两个基本操作查询与合并时，我们都要维护这两个信息。

对于查询操作，我们考虑到时间复杂度的问题，因此需要进行路径压缩。伪代码如下：

```
FIND(x)
    if x != father[x]
        LET former_father = fa[x]
        fa[x] = FIND(fa[x])
        d[x] = d[x] + d[former_father]
        cnt[x] = cnt[former_mather]
    RETURN fa[x]
```

对于合并操作，因为本题中的合并有顺序，因此不能使用按秩合并优化。伪代码如下：

```
MERGE(x, y)
    x = FIND(x)
    y = FIND(y)
    fa[x] = y
    d[x] = d[y] + cnt[y]
    cnt[y] = cnt[y] + cnt[x]
    cnt[x] = cnt[y]
```

需要注意的是这里合并之后 `d[x]` 的值并不是正确的。但是在 $\mathrm{FIND}$ 之后可以维护成正确的。

处理 $C_{i, j}$操作时，如果 $\mathrm{FIND}(i) \neq \mathrm{FIND}(j)$，则两艘战舰不在同一列。否则他们的距离就是 $\vert d[x] - d[y] \vert - 1$。

# 代码

```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <iostream>

const int MAXN = 30000 + 5;

int fa[MAXN], cnt[MAXN], d[MAXN], t /*  */;

int find(int x) {
    if (x != fa[x]) {
        int k = fa[x];
        fa[x] = find(fa[x]);
        d[x] = d[x] + d[k];
        cnt[x] = cnt[k];
    }
    return fa[x];
}

void merge(int x, int y) {
    x = find(x);
    y = find(y);
    fa[x] = y;
    d[x] = d[y] + cnt[y];
    cnt[y] += cnt[x];
    cnt[x] = cnt[y];
}

int main() {
    scanf("%d\n", &t);
    for (int i = 1; i <= 30000; ++i) {
        fa[i] = i;
        d[i] = 0;
        cnt[i] = 1;
    }
    char c;
    int x, y;
    while (t--) {
        std::cin >> c >> x >> y;
        if (c == 'M') {
            merge(x, y);
        } else if (c == 'C') {
            int a = find(x), b = find(y);
            if (a != b) {
                printf("-1\n");
                continue;
            } else {
                printf("%d\n", std::abs(d[x] - d[y]) - 1);
            }
        }
    }
    return 0;
}
```

Finita la comedia.